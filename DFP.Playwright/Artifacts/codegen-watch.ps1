param(
    [Parameter(Mandatory=$false)]
    [string]$ArtifactsRoot = "D:\AnniaSources\DFP\DFP.Playwright\Artifacts",
    [Parameter(Mandatory=$false)]
    [string]$SelectorsRoot = "D:\AnniaSources\DFP\DFP.Playwright\Artifacts\Selectors",
    [Parameter(Mandatory=$false)]
    [string]$GeneratedSelectorsPath = "D:\AnniaSources\DFP\DFP.Playwright\Support\Selectors.generated.cs"
)

function Get-SelectorsFromJsonl([string]$path, [int]$startLine) {
    if (!(Test-Path $path)) { return @() }
    $lines = Get-Content -Path $path
    if ($startLine -gt 0 -and $lines.Count -ge $startLine) {
        $lines = $lines[$startLine..($lines.Count - 1)]
    }
    $selectors = New-Object System.Collections.Generic.List[string]

    function Recurse($obj) {
        if ($null -eq $obj) { return }
        if ($obj -is [System.Collections.IDictionary]) {
            foreach ($k in $obj.Keys) {
                $v = $obj[$k]
                if ($k -eq "selector" -and $v -is [string] -and $v.Trim().Length -gt 0) {
                    $selectors.Add($v)
                }
                Recurse $v
            }
        } elseif ($obj -is [psobject]) {
            foreach ($p in $obj.PSObject.Properties) {
                $k = $p.Name
                $v = $p.Value
                if ($k -eq "selector" -and $v -is [string] -and $v.Trim().Length -gt 0) {
                    $selectors.Add($v)
                }
                Recurse $v
            }
        } elseif ($obj -is [System.Collections.IEnumerable] -and -not ($obj -is [string])) {
            foreach ($item in $obj) { Recurse $item }
        }
    }

    foreach ($line in $lines) {
        if ([string]::IsNullOrWhiteSpace($line)) { continue }
        try {
            $obj = $line | ConvertFrom-Json -ErrorAction Stop
            Recurse $obj
        } catch {
            # ignore malformed lines
        }
    }

    return $selectors | Sort-Object -Unique
}

function Infer-LoginSelectors($all) {
    $username = $all | Where-Object { $_ -match "Username" -and $_ -match "role=|textbox|input" } | Select-Object -First 1
    $password = $all | Where-Object { $_ -match "Password" -and $_ -match "role=|textbox|input" } | Select-Object -First 1
    $submit = $all | Where-Object { $_ -match "Sign in" -and $_ -match "role=|button" } | Select-Object -First 1

    return @{
        username = $username
        password = $password
        submit = $submit
    }
}

function Normalize-Selector([string]$s) {
    if ([string]::IsNullOrWhiteSpace($s)) { return $s }

    # Convert getByRole('textbox', { name: 'Username' }) -> role=textbox[name='Username']
    $m = [regex]::Match($s, "getByRole\\('([^']+)'\\s*,\\s*\\{\\s*name:\\s*'([^']+)'\\s*\\}\\)")
    if ($m.Success) {
        return ("role={0}[name='{1}']" -f $m.Groups[1].Value, $m.Groups[2].Value)
    }

    return $s
}

function Write-SelectorsJson($path, $pageKey, $all, $login) {
    $selectors = @()
    if ($all) { $selectors = @($all) }
    $obj = [ordered]@{
        page = $pageKey
        generatedAt = (Get-Date).ToString("o")
        selectors = $selectors
    }
    if ($null -ne $login) {
        $obj.login = $login
    }
    $obj | ConvertTo-Json -Depth 5 | Set-Content -Path $path
}

function Make-Identifier([string]$s) {
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }
    $t = $s -replace "[^A-Za-z0-9]", "_"
    if ($t -match "^[0-9]") { $t = "S_" + $t }
    return $t
}

function Escape-CSharpString([string]$s) {
    if ($null -eq $s) { return $s }
    $t = $s -replace "\\", "\\\\"
    $t = $t -replace '"', '\"'
    $t = $t -replace "`r", "\r"
    $t = $t -replace "`n", "\n"
    return $t
}

function Build-GeneratedSelectors($pageMaps) {
    $sb = New-Object System.Text.StringBuilder

    $null = $sb.AppendLine('// <auto-generated />')
    $null = $sb.AppendLine('namespace DFP.Playwright.Support')
    $null = $sb.AppendLine('{')
    $null = $sb.AppendLine('    public static class Selectors')
    $null = $sb.AppendLine('    {')

    foreach ($pageKey in $pageMaps.Keys) {
        $data = $pageMaps[$pageKey]
        $className = (Make-Identifier $pageKey)
        if ([string]::IsNullOrWhiteSpace($className)) { continue }

        $null = $sb.AppendLine(('        public static class {0}' -f $className))
        $null = $sb.AppendLine('        {')

        if ($data.login) {
            if ($data.login.username) { $null = $sb.AppendLine(('            public const string Username = "{0}";' -f (Escape-CSharpString $data.login.username))) }
            if ($data.login.password) { $null = $sb.AppendLine(('            public const string Password = "{0}";' -f (Escape-CSharpString $data.login.password))) }
            if ($data.login.submit) { $null = $sb.AppendLine(('            public const string Submit = "{0}";' -f (Escape-CSharpString $data.login.submit))) }
        }

        if ($data.selectors -and $data.selectors.Count -gt 0) {
            $null = $sb.AppendLine('            public static readonly string[] All = new[]')
            $null = $sb.AppendLine('            {')
            foreach ($s in $data.selectors) {
                $null = $sb.AppendLine(('                "{0}",' -f (Escape-CSharpString $s)))
            }
            $null = $sb.AppendLine('            };')
        }

        $null = $sb.AppendLine('        }')
    }

    $null = $sb.AppendLine('    }')
    $null = $sb.AppendLine('}')

    return $sb.ToString()
}

function Update-LoginPageIfPresent([string]$path, $login) {
    if (!(Test-Path $path)) { return }

    $u = $login.username
    $p = $login.password
    $s = $login.submit

    if ([string]::IsNullOrWhiteSpace($u) -or [string]::IsNullOrWhiteSpace($p) -or [string]::IsNullOrWhiteSpace($s)) {
        return
    }

    $block = @"
        private static readonly string[] UsernameSelectors =
        {
            \"$u\"
        };

        private static readonly string[] PasswordSelectors =
        {
            \"$p\"
        };

        private static readonly string[] SignInButtonSelectors =
        {
            \"$s\"
        };
"@

    $content = Get-Content -Raw $path
    $updated = [regex]::Replace(
        $content,
        "// codegen:login-start([\s\S]*?)// codegen:login-end",
        "// codegen:login-start`r`n$block`r`n        // codegen:login-end"
    )

    Set-Content -Path $path -Value $updated
}

function Process-JsonlFile([string]$jsonlPath) {
    $fileName = [System.IO.Path]::GetFileNameWithoutExtension($jsonlPath)
    # codegen.<page>
    $pageKey = $fileName -replace "^codegen\.", ""

    $all = Get-SelectorsFromJsonl $jsonlPath 0 | ForEach-Object { Normalize-Selector $_ }

    # For non-login pages, drop obvious login-modal selectors
    if ($pageKey -ne "login") {
        $all = $all | Where-Object {
            $_ -notmatch "qwyk-login-modal" -and
            $_ -notmatch "role=textbox\\[name='Username'\\]" -and
            $_ -notmatch "role=textbox\\[name='Password'\\]" -and
            $_ -notmatch "role=button\\[name='Sign in'\\]"
        }
    }
    $login = $null
    if ($pageKey -eq "login") {
        $login = Infer-LoginSelectors $all
    }

    $selectorsPath = Join-Path $SelectorsRoot ("selectors.{0}.json" -f $pageKey)
    # Merge with existing selectors for this page (if any)
    $existing = @()
    if (Test-Path $selectorsPath) {
        try {
            $objExisting = Get-Content -Raw $selectorsPath | ConvertFrom-Json
            if ($objExisting -and $objExisting.selectors) {
                $existing = @($objExisting.selectors)
            }
        } catch {
            # ignore malformed existing file
        }
    }
    $merged = @($existing + $all) | Where-Object { $_ -and $_.Trim().Length -gt 0 } | Sort-Object -Unique
    Write-SelectorsJson $selectorsPath $pageKey $merged $login

    # Update LoginPage.cs only for login page key
    if ($pageKey -eq "login") {
        Update-LoginPageIfPresent "D:\AnniaSources\DFP\DFP.Playwright\Pages\Web\LoginPage.cs" $login
    }
}

function Build-AllGeneratedSelectors {
    $pageMaps = @{}
    $selectorFiles = Get-ChildItem -Path $SelectorsRoot -Filter "selectors.*.json" -File -ErrorAction SilentlyContinue

    foreach ($file in $selectorFiles) {
        try {
            $obj = Get-Content -Raw $file.FullName | ConvertFrom-Json
            $pageKey = $obj.page
            if ([string]::IsNullOrWhiteSpace($pageKey)) { continue }
            $pageMaps[$pageKey] = @{ selectors = $obj.selectors; login = $obj.login }
        } catch {
            # ignore
        }
    }

    $content = Build-GeneratedSelectors $pageMaps
    $dir = Split-Path -Parent $GeneratedSelectorsPath
    if (!(Test-Path $dir)) { New-Item -ItemType Directory -Force $dir | Out-Null }
    Set-Content -Path $GeneratedSelectorsPath -Value $content
}

function Run-UpdateForAll {
    $jsonlFiles = Get-ChildItem -Path $ArtifactsRoot -Filter "codegen.*.jsonl" -File -ErrorAction SilentlyContinue
    foreach ($f in $jsonlFiles) { Process-JsonlFile $f.FullName }
    Build-AllGeneratedSelectors
    Write-Host "Updated selectors.*.json and Selectors.generated.cs"
}

# Initial run
Run-UpdateForAll

$watcher = New-Object System.IO.FileSystemWatcher
$watcher.Path = $ArtifactsRoot
$watcher.Filter = "codegen.*.jsonl"
$watcher.NotifyFilter = [System.IO.NotifyFilters]::LastWrite
$watcher.EnableRaisingEvents = $true

Register-ObjectEvent $watcher Changed -SourceIdentifier CodegenJsonlChanged -Action {
    Start-Sleep -Milliseconds 200
    Run-UpdateForAll
} | Out-Null

Write-Host "Watching $ArtifactsRoot for codegen.*.jsonl updates. Press Ctrl+C to stop."
while ($true) { Start-Sleep -Seconds 1 }
